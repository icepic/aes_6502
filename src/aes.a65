//======================================================================
// aes.a65
// -------
// An implementation of the AES-128 block cipher (NIST FIPS-197) for
// the MOS 6502/6510 CPU. The implementation is aimed at low
// cycles/round.
//
// Limitation:
// Currently will only do encipher operation, but one would use
// a cipher mode that provides deciphering outside of the AES itself.
// Key expansion is currently not being implemented.
//
// Implementation note:
// Key and state are stored in zero page using addresses used
// by the BASIC interpreter. Add code to save/restore these values
// before calling the code if BASIC operation is something you
// care about.
//
//
// (c) 2017 Joachim Str√∂mbergson
//======================================================================

//------------------------------------------------------------------
// Labels
//------------------------------------------------------------------
// State is 16 bytes in size.
.label state = $30

// Expanded key is 11*16 bytes in size
// So will span from $40 to $f0
.label exp_keys = $40

// Round counter
.label rctr = $f8

// Key pointer
.label keyptr = $f9

// Block temp values. 6 bytes in size ($fa .. $ff).
.label btmp = $fa


//------------------------------------------------------------------
// Macros.
//------------------------------------------------------------------
.macro sbyte(byte)
{
                ldy byte                // 3 cycles
                lda sbox, y             // 4 cycles
                sta byte                // 3 cycles
}


// XOR the contents of the keybyte with sbyte. The result is
// stored in sbyte.
// Note: Assumes that x reg has been set.
.macro eorbyte(sbyte, keybyte)
{
                lda keybyte, x          // 4 cycles
                eor sbyte               // 3 cycles
                sta sbyte               // 3 cycles
}


// Galois Multiplication by two.
.macro gm2(byte, res)
{
                lda byte
                asl
                bcs gm2_1
                adc #$1b
gm2_1:          sta res
}


// Galois mult by three.
.macro gm3(byte, res)
{
                lda byte
                asl
                bcs gm3_1
                adc #$1b
gm3_1:          eor byte
                sta res
}


// mixc. Mixes four bytes to get a new byte.
// Note: Will modyfy btmp and btmp+1 as part of processing.
.macro mixb(b0, b1, b2, b3, dest)
{
                :gm2(b0, btmp)
                :gm3(b1, btmp + 1)
                lda btmp
                eor btmp + 1
                eor b2
                eor b3
                sta dest
}


// mixc. Mixes fou bytes to get four new bytes.
// Note: Will modyfy btmp..btmp+5 as part of processing.
.macro mixc(b0, b1, b2, b3)
{
                :mixb(b0, b1, b2, b3, btmp + 2)
                :mixb(b1, b2, b3, b0, btmp + 3)
                :mixb(b2, b3, b0, b1, btmp + 4)
                :mixb(b3, b0, b1, b2, btmp + 5)
                lda btmp + 2
                sta b0
                lda btmp + 3
                sta b1
                lda btmp + 4
                sta b2
                lda btmp + 5
                sta b3
}


.macro print_string(str_ptr, len, screen_ptr)
{
                ldx #$00
pstr1:          lda str_ptr, x
                sta screen_ptr, x
                inx
                cpx #len
                bne pstr1
}


.macro print_state_matrix(screen_ptr)
{
                :print_hexvalue(state + 00, screen_ptr)
                :print_hexvalue(state + 01, screen_ptr + 3)
                :print_hexvalue(state + 02, screen_ptr + 6)
                :print_hexvalue(state + 03, screen_ptr + 9)

                :print_hexvalue(state + 04, screen_ptr + 40)
                :print_hexvalue(state + 05, screen_ptr + 43)
                :print_hexvalue(state + 06, screen_ptr + 46)
                :print_hexvalue(state + 07, screen_ptr + 49)

                :print_hexvalue(state + 08, screen_ptr + 80)
                :print_hexvalue(state + 09, screen_ptr + 83)
                :print_hexvalue(state + 10, screen_ptr + 86)
                :print_hexvalue(state + 11, screen_ptr + 89)

                :print_hexvalue(state + 12, screen_ptr + 120)
                :print_hexvalue(state + 13, screen_ptr + 123)
                :print_hexvalue(state + 14, screen_ptr + 126)
                :print_hexvalue(state + 15, screen_ptr + 129)
}


.macro print_hexvalue(byte, screen_ptr)
{
                lda byte
                lsr
                lsr
                lsr
                lsr
                tax
                lda hexchars, x
                sta screen_ptr

                lda byte
                and #$0f
                tax
                lda hexchars, x
                sta screen_ptr + 1
}


//------------------------------------------------------------------
// Basic start code.
//------------------------------------------------------------------
.pc = $0801     "Basic uppstart"
	        :BasicUpstart(start)


//------------------------------------------------------------------
//------------------------------------------------------------------
// Main program implements a few tests by calling the AES code
.pc = $1000     "Main code"
start:
                sei
                inc $d020
                lda $d018
                ora #$02
                sta $d018
                jsr clear_screen
                jsr save_zp
                jsr init_aes
                jsr aes_encipher
                jsr restore_zp
                cli
                rts


//------------------------------------------------------------------
//------------------------------------------------------------------
clear_screen:
                ldx #$00
                lda #$20
l1:             sta $0400,x
                sta $0500,x
                sta $0600,x
                sta $0700,x
                dex
                bne l1
                rts

//------------------------------------------------------------------
//------------------------------------------------------------------
set_state:
                lda #$41
                ldy #$00
s1:             sta state,y
                adc #$01
                iny
                cpy #$10
                bne s1
                rts


//------------------------------------------------------------------
//------------------------------------------------------------------
save_zp:
                ldx #$00
save1:          lda exp_keys, x
                sta backup_zp_exp_keys, x
                inx
                cpx #$b0
                bne save1

                ldx #$00
save2:          lda state, x
                sta backup_zp_state, x
                inx
                cpx #$10
                bne save2
                rts


//------------------------------------------------------------------
//------------------------------------------------------------------
restore_zp:
                ldx #$00
restore1:
                lda backup_zp_exp_keys, x
                sta exp_keys, x
                inx
                cpx #$b0
                bne restore1

                ldx #$00
restore2:
                lda backup_zp_state, x
                sta state, x
                inx
                cpx #$10
                bne restore2
                rts

//------------------------------------------------------------------
// init_aes
// Copy expanded keys into the exp_keys area.
// Write the plaintext to the state in correct column order.
//------------------------------------------------------------------
init_aes:
                ldx #$00
init1:
                lda fips_keys, x
                sta exp_keys, x
                inx
                cpx #$b0
                bne init1

                ldx #$00
init2:
                lda plaintext + 0
                sta state + 0
                lda plaintext + 1
                sta state + 4
                lda plaintext + 2
                sta state + 8
                lda plaintext + 3
                sta state + 12

                lda plaintext + 4
                sta state + 1
                lda plaintext + 5
                sta state + 5
                lda plaintext + 6
                sta state + 9
                lda plaintext + 7
                sta state + 13

                lda plaintext + 8
                sta state + 2
                lda plaintext + 9
                sta state + 6
                lda plaintext + 10
                sta state + 10
                lda plaintext + 11
                sta state + 14

                lda plaintext + 12
                sta state + 3
                lda plaintext + 13
                sta state + 7
                lda plaintext + 14
                sta state + 11
                lda plaintext + 15
                sta state + 15
                rts


//------------------------------------------------------------------
// aes_encipher
// Perform one AES-128 given a block of data written into the
// state and a key written into the key addresses.
//------------------------------------------------------------------

.pc = $3000     "AES Encipher"
aes_encipher:
                lda #$00
                sta rctr
                sta keyptr

                :print_string(aes_state_str, 10, $0400)
                :print_state_matrix($0428)

                jsr addroundkey

                :print_string(aes_state_str, 10, $0410)
                :print_state_matrix($0438)

round_loop:
                jsr subbytes
                jsr shiftrows
                jsr mixcolumns

                rts


//------------------------------------------------------------------
// SubBytes
// Replace each byte in the state with a byte in the S-box
// pointed to by the state byte value.
//
// Cycle calc: 10 * 16 + 6 = 166 cycles.
//------------------------------------------------------------------
subbytes:
                :sbyte(state + 0)
                :sbyte(state + 1)
                :sbyte(state + 2)
                :sbyte(state + 3)
                :sbyte(state + 4)
                :sbyte(state + 5)
                :sbyte(state + 6)
                :sbyte(state + 7)
                :sbyte(state + 8)
                :sbyte(state + 9)
                :sbyte(state + 10)
                :sbyte(state + 11)
                :sbyte(state + 12)
                :sbyte(state + 13)
                :sbyte(state + 14)
                :sbyte(state + 15)
                rts              // 6 cycles


//------------------------------------------------------------------
// ShiftRows
// Rotate the bytes in the rows of the matrix 0..3 steps left.
// 30 + 36 + 30 + 6 = 102 cycles.
//------------------------------------------------------------------
shiftrows:
                // Second row one step left.
                // 10 * 3 = 30 cycles.
                lda state + 4
                sta btmp
                lda state + 5
                sta state + 4
                lda state + 6
                sta state + 5
                lda state + 7
                sta state + 6
                lda btmp
                sta state + 7

                // Third row two steps left.
                // 12 * 3 = 36 cycles
                lda state + 8
                sta btmp
                lda state + 9
                sta btmp + 1
                lda state + 10
                sta state + 8
                lda state + 11
                sta state + 9
                lda btmp
                sta state + 10
                lda btmp + 1
                sta state + 11

                // Fourth row three steps left.
                // Same as one step right.
                // 10 * 3 = 30 cycles
                lda state + 15
                sta btmp
                lda state + 14
                sta state + 15
                lda state + 13
                sta state + 14
                lda state + 12
                sta state + 13
                lda btmp
                sta state + 12
                rts


//------------------------------------------------------------------
// MixColumns
// GF mult mix columns together.
//------------------------------------------------------------------
mixcolumns:
                mixc(state + 0, state + 4, state + 8,  state + 12)
                mixc(state + 1, state + 5, state + 9,  state + 13)
                mixc(state + 2, state + 6, state + 10, state + 14)
                mixc(state + 3, state + 7, state + 11, state + 15)
                rts


//------------------------------------------------------------------
// AddRoundKey
// XOR mix a given round key with the round state.
// 3 + 16 * 10 + 13 = 176 cycles
//------------------------------------------------------------------
addroundkey:
                ldx keyptr                              // 3 cycles
                :eorbyte(state + 0,  exp_keys + 0)
                :eorbyte(state + 1,  exp_keys + 1)
                :eorbyte(state + 2,  exp_keys + 2)
                :eorbyte(state + 3,  exp_keys + 3)
                :eorbyte(state + 4,  exp_keys + 4)
                :eorbyte(state + 5,  exp_keys + 5)
                :eorbyte(state + 6,  exp_keys + 6)
                :eorbyte(state + 7,  exp_keys + 7)
                :eorbyte(state + 8,  exp_keys + 8)
                :eorbyte(state + 9,  exp_keys + 9)
                :eorbyte(state + 10, exp_keys + 10)
                :eorbyte(state + 11, exp_keys + 11)
                :eorbyte(state + 12, exp_keys + 12)
                :eorbyte(state + 13, exp_keys + 13)
                :eorbyte(state + 14, exp_keys + 14)
                :eorbyte(state + 15, exp_keys + 15)
                txa                                     // 2 cycles
                adc #$10                                // 2 cycles
                sta keyptr                              // 3 cycles
                rts                                     // 6 cycles


//------------------------------------------------------------------
// AES S-Box.
//------------------------------------------------------------------
.pc = $4000     "Sboxes"
sbox:
.byte $63, $7c, $77, $7b, $f2, $6b, $6f, $c5
.byte $30, $01, $67, $2b, $fe, $d7, $ab, $76
.byte $ca, $82, $c9, $7d, $fa, $59, $47, $f0
.byte $ad, $d4, $a2, $af, $9c, $a4, $72, $c0
.byte $b7, $fd, $93, $26, $36, $3f, $f7, $cc
.byte $34, $a5, $e5, $f1, $71, $d8, $31, $15
.byte $04, $c7, $23, $c3, $18, $96, $05, $9a
.byte $07, $12, $80, $e2, $eb, $27, $b2, $75
.byte $09, $83, $2c, $1a, $1b, $6e, $5a, $a0
.byte $52, $3b, $d6, $b3, $29, $e3, $2f, $84
.byte $53, $d1, $00, $ed, $20, $fc, $b1, $5b
.byte $6a, $cb, $be, $39, $4a, $4c, $58, $cf
.byte $d0, $ef, $aa, $fb, $43, $4d, $33, $85
.byte $45, $f9, $02, $7f, $50, $3c, $9f, $a8
.byte $51, $a3, $40, $8f, $92, $9d, $38, $f5
.byte $bc, $b6, $da, $21, $10, $ff, $f3, $d2
.byte $cd, $0c, $13, $ec, $5f, $97, $44, $17
.byte $c4, $a7, $7e, $3d, $64, $5d, $19, $73
.byte $60, $81, $4f, $dc, $22, $2a, $90, $88
.byte $46, $ee, $b8, $14, $de, $5e, $0b, $db
.byte $e0, $32, $3a, $0a, $49, $06, $24, $5c
.byte $c2, $d3, $ac, $62, $91, $95, $e4, $79
.byte $e7, $c8, $37, $6d, $8d, $d5, $4e, $a9
.byte $6c, $56, $f4, $ea, $65, $7a, $ae, $08
.byte $ba, $78, $25, $2e, $1c, $a6, $b4, $c6
.byte $e8, $dd, $74, $1f, $4b, $bd, $8b, $8a
.byte $70, $3e, $b5, $66, $48, $03, $f6, $0e
.byte $61, $35, $57, $b9, $86, $c1, $1d, $9e
.byte $e1, $f8, $98, $11, $69, $d9, $8e, $94
.byte $9b, $1e, $87, $e9, $ce, $55, $28, $df
.byte $8c, $a1, $89, $0d, $bf, $e6, $42, $68
.byte $41, $99, $2d, $0f, $b0, $54, $bb, $16

// Screen Strings.
aes_state_str:
.text "AES state:"

subbytes_str:
.text "SubBytes:"

shiftrows_str:
.text "ShiftRows:"

mixcolumns_str:
.text "MixColumns:"

addroundkey_str:
.text "AddRoundKey:"

hexchars:
.text "0123456789abcdef"


plaintext:
.byte $32, $43, $f6, $a8, $88, $5a, $30, $8d, $31, $31, $98, $a2, $e0, $37, $07, $34


ciphertext:
.byte $39, $25, $84, $1d, $02, $dc, $09, $fb, $dc, $11, $85, $97, $19, $6a, $0b, $32


fips_keys:
.byte $2b, $7e, $15, $16, $28, $ae, $d2, $a6, $ab, $f7, $15, $88, $09, $cf, $4f, $3c
.byte $a0, $fa, $fe, $17, $88, $54, $2c, $b1, $23, $a3, $39, $39, $2a, $6c, $76, $05
.byte $f2, $c2, $95, $f2, $7a, $96, $b9, $43, $59, $35, $80, $7a, $73, $59, $f6, $7f
.byte $3d, $80, $47, $7d, $47, $16, $fe, $3e, $1e, $23, $7e, $44, $6d, $7a, $88, $3b
.byte $ef, $44, $a5, $41, $a8, $52, $5b, $7f, $b6, $71, $25, $3b, $db, $0b, $ad, $00
.byte $d4, $d1, $c6, $f8, $7c, $83, $9d, $87, $ca, $f2, $b8, $bc, $11, $f9, $15, $bc
.byte $6d, $88, $a3, $7a, $11, $0b, $3e, $fd, $db, $f9, $86, $41, $ca, $00, $93, $fd
.byte $4e, $54, $f7, $0e, $5f, $5f, $c9, $f3, $84, $a6, $4f, $b2, $4e, $a6, $dc, $4f
.byte $ea, $d2, $73, $21, $b5, $8d, $ba, $d2, $31, $2b, $f5, $60, $7f, $8d, $29, $2f
.byte $ac, $77, $66, $f3, $19, $fa, $dc, $21, $28, $d1, $29, $41, $57, $5c, $00, $6e
.byte $d0, $14, $f9, $a8, $c9, $ee, $25, $89, $e1, $3f, $0c, $c8, $b6, $63, $0c, $a6


// This is where we store the backup of the zero page we use
// for state and expanded keys.
backup_zp_exp_keys:
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00


backup_zp_state:
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

//======================================================================
// aes.a65
//======================================================================
