//======================================================================
// aes.a65
// -------
// An implementation of the AES-128 block cipher (NIST FIPS-197) for
// the MOS 6502/6510 CPU. The implementation is aimed at low
// cycles/round.
//
// Limitation:
// Currently will only do encipher operation, but one would use
// a cipher mode that provides deciphering outside of the AES itself.
// Key expansion is currently not being implemented.
//
// Implementation note:
// Key and state are stored in zero page using addresses used
// by the BASIC interpreter. Add code to save/restore these values
// before calling the code if BASIC operation is something you
// care about.
//
//
// (c) 2017 Joachim Str√∂mbergson
//======================================================================

//------------------------------------------------------------------
// Labels
//------------------------------------------------------------------
// State is 16 bytes in size.
.label state = $30

// Expanded key is 11*16 bytes in size
// So will span from $40 to $f0
.label exp_key = $40

// Round counter
.label rctr = $f8

// Key pointer
.label keyptr = $f9

// Block temp values is 3 bytes in size.
.label btmp = $fa


//------------------------------------------------------------------
// Basic start code.
//------------------------------------------------------------------
.pc = $0801     "Basic uppstart"
	:BasicUpstart(start)


//------------------------------------------------------------------
//------------------------------------------------------------------
// Main program implements a few tests by calling the AES code
.pc = $1000     "Main code"
start:
                inc $d020
                lda $d018
                ora #$02
                sta $d018
                jsr clear_screen
                jsr set_state
                :print_string(aes_state_str, 10, $0400)
                :print_state_matrix($0428)

                jsr subbytes
                :print_string(subbytes_str, 9, $0410)
                :print_state_matrix($0438)

                jsr shiftrows
                :print_string(shiftrows_str, 10, $04f0)
                :print_state_matrix($0518)
                rts

clear_screen:
                ldx #$00
                lda #$20
l1:             sta $0400,x
                sta $0500,x
                sta $0600,x
                sta $0700,x
                dex
                bne l1
                rts

set_state:
                lda #$41
                ldy #$00
s1:             sta state,y
                adc #$01
                iny
                cpy #$10
                bne s1
                rts


//------------------------------------------------------------------
// aes_encipher
// Perform one AES-128 given a block of data written into the
// state and a key written into the key addresses.
//------------------------------------------------------------------

.pc = $3000     "AES Encipher"
aes_encipher:
                sei
                lda #$00
                sta rctr
                sta keyptr

aes1:
                inc rctr
                cmp #$0b
                bne aes1

                cli
                rts


//------------------------------------------------------------------
// SubBytes
// Replace each byte in the state with a byte in the S-box
// pointed to by the state byte value.
//
// Cycle calc: 10 * 16 + 6 = 166 cycles.
//------------------------------------------------------------------
subbytes:
                ldy state + $0 // 3 cycles
                lda sbox, y    // 4 cycles
                sta state + $0 // 3 cycles

                ldy state + $1
                lda sbox, y
                sta state + $1

                ldy state + $2
                lda sbox, y
                sta state + $2

                ldy state + $3
                lda sbox, y
                sta state + $3

                ldy state + $4
                lda sbox, y
                sta state + $4

                ldy state + $5
                lda sbox, y
                sta state + $5

                ldy state + $6
                lda sbox, y
                sta state + $6

                ldy state + $7
                lda sbox, y
                sta state + $7

                ldy state + $8
                lda sbox, y
                sta state + $8

                ldy state + $9
                lda sbox, y
                sta state + $9

                ldy state + $a
                lda sbox, y
                sta state + $a

                ldy state + $b
                lda sbox, y
                sta state + $b

                ldy state + $c
                lda sbox, y
                sta state + $c

                ldy state + $d
                lda sbox, y
                sta state + $d

                ldy state + $e
                lda sbox, y
                sta state + $e

                ldy state + $f
                lda sbox, y
                sta state + $f
                rts              // 6 cycles


//------------------------------------------------------------------
// ShiftRows
// Rotate the bytes in the rows of the matrix 0..3 steps left.
// 30 + 36 + 30 + 6 = 102 cycles.
//------------------------------------------------------------------
shiftrows:
                // Second row one step left.
                // 10 * 3 = 30 cycles.
                lda state + 4
                sta btmp
                lda state + 5
                sta state + 4
                lda state + 6
                sta state + 5
                lda state + 7
                sta state + 6
                lda btmp
                sta state + 7

                // Third row two steps left.
                // 12 * 3 = 36 cycles
                lda state + 8
                sta btmp
                lda state + 9
                sta btmp + 1
                lda state + 10
                sta state + 8
                lda state + 11
                sta state + 9
                lda btmp
                sta state + 10
                lda btmp + 1
                sta state + 11

                // Fourth row three steps left.
                // Same as one step right.
                // 10 * 3 = 30 cycles
                lda state + 15
                sta btmp
                lda state + 14
                sta state + 15
                lda state + 13
                sta state + 14
                lda state + 12
                sta state + 13
                lda btmp
                sta state + 12

                rts


//------------------------------------------------------------------
// MixColumns
// GF mult mix columns together.
//------------------------------------------------------------------
mixcolumns:
                rts



//------------------------------------------------------------------
// AddRoundKey
// XOR mix a given round key with the round state.
// 3 + 16 * 10 + 13 = 176 cycles
//------------------------------------------------------------------
addroundkey:
                ldx keyptr             // 3 cycles

                lda exp_key + 0, x   // 4 cycles
                eor state + 0        // 3 cycles
                sta state + 0        // 3 cycles

                lda exp_key + 1, x
                eor state + 1
                sta state + 1

                lda exp_key + 2, x
                eor state + 2
                sta state + 2

                lda exp_key + 3, x
                eor state + 3
                sta state + 3

                lda exp_key + 4, x
                eor state + 4
                sta state + 4

                lda exp_key + 5, x
                eor state + 5
                sta state + 5

                lda exp_key + 6, x
                eor state + 6
                sta state + 6

                lda exp_key + 7, x
                eor state + 7
                sta state + 7

                lda exp_key + 8, x
                eor state + 8
                sta state + 8

                lda exp_key + 9, x
                eor state + 9
                sta state + 9

                lda exp_key + 10, x
                eor state + 10
                sta state + 10

                lda exp_key + 11, x
                eor state + 11
                sta state + 11

                lda exp_key + 12, x
                eor state + 12
                sta state + 12

                lda exp_key + 13, x
                eor state + 13
                sta state + 13

                lda exp_key + 14, x
                eor state + 14
                sta state + 14

                lda exp_key + 15, x
                eor state + 15
                sta state + 15

                txa                  // 2 cycles
                adc #$10             // 2 cycles
                sta keyptr           // 3 cycles
                rts                  // 6 cycles


//------------------------------------------------------------------
// nist_exp_keys
//
// Expanded keys from NIST FIPS 197.
//------------------------------------------------------------------
nist_exp_keys:


//------------------------------------------------------------------
// AES S-Box.
//------------------------------------------------------------------
.pc = $4000     "Sboxes"
sbox:
.byte $63, $7c, $77, $7b, $f2, $6b, $6f, $c5
.byte $30, $01, $67, $2b, $fe, $d7, $ab, $76
.byte $ca, $82, $c9, $7d, $fa, $59, $47, $f0
.byte $ad, $d4, $a2, $af, $9c, $a4, $72, $c0
.byte $b7, $fd, $93, $26, $36, $3f, $f7, $cc
.byte $34, $a5, $e5, $f1, $71, $d8, $31, $15
.byte $04, $c7, $23, $c3, $18, $96, $05, $9a
.byte $07, $12, $80, $e2, $eb, $27, $b2, $75
.byte $09, $83, $2c, $1a, $1b, $6e, $5a, $a0
.byte $52, $3b, $d6, $b3, $29, $e3, $2f, $84
.byte $53, $d1, $00, $ed, $20, $fc, $b1, $5b
.byte $6a, $cb, $be, $39, $4a, $4c, $58, $cf
.byte $d0, $ef, $aa, $fb, $43, $4d, $33, $85
.byte $45, $f9, $02, $7f, $50, $3c, $9f, $a8
.byte $51, $a3, $40, $8f, $92, $9d, $38, $f5
.byte $bc, $b6, $da, $21, $10, $ff, $f3, $d2
.byte $cd, $0c, $13, $ec, $5f, $97, $44, $17
.byte $c4, $a7, $7e, $3d, $64, $5d, $19, $73
.byte $60, $81, $4f, $dc, $22, $2a, $90, $88
.byte $46, $ee, $b8, $14, $de, $5e, $0b, $db
.byte $e0, $32, $3a, $0a, $49, $06, $24, $5c
.byte $c2, $d3, $ac, $62, $91, $95, $e4, $79
.byte $e7, $c8, $37, $6d, $8d, $d5, $4e, $a9
.byte $6c, $56, $f4, $ea, $65, $7a, $ae, $08
.byte $ba, $78, $25, $2e, $1c, $a6, $b4, $c6
.byte $e8, $dd, $74, $1f, $4b, $bd, $8b, $8a
.byte $70, $3e, $b5, $66, $48, $03, $f6, $0e
.byte $61, $35, $57, $b9, $86, $c1, $1d, $9e
.byte $e1, $f8, $98, $11, $69, $d9, $8e, $94
.byte $9b, $1e, $87, $e9, $ce, $55, $28, $df
.byte $8c, $a1, $89, $0d, $bf, $e6, $42, $68
.byte $41, $99, $2d, $0f, $b0, $54, $bb, $16


//------------------------------------------------------------------
// Macros.
//------------------------------------------------------------------
// Galois Multiplication by two.
.macro gm2(byte, res)
{
                lda byte
                asl
                bcs gm2_1
                adc #$1b
gm2_1:          sta res
}

// Galois mult by three.
.macro gm3(byte, res)
{
                lda byte
                asl
                bcs gm3_1
                adc #$1b
gm3_1:          eor byte
                sta res
}


.macro mixc(b0, b1, b2, b3, dest)
{
                :gm2(b0, btmp)
                :gm3(b1, btmp + 1)
                lda btmp
                eor btmp + 1
                eor b2
                eor b3
                sta dest
}


.macro print_string(str_ptr, len, screen_ptr)
{
                ldx #$00
pstr1:          lda str_ptr, x
                sta screen_ptr, x
                inx
                cpx #len
                bne pstr1
}

.macro print_state_matrix(screen_ptr)
{
                :print_hexvalue(state + 00, screen_ptr)
                :print_hexvalue(state + 01, screen_ptr + 3)
                :print_hexvalue(state + 02, screen_ptr + 6)
                :print_hexvalue(state + 03, screen_ptr + 9)

                :print_hexvalue(state + 04, screen_ptr + 40)
                :print_hexvalue(state + 05, screen_ptr + 43)
                :print_hexvalue(state + 06, screen_ptr + 46)
                :print_hexvalue(state + 07, screen_ptr + 49)

                :print_hexvalue(state + 08, screen_ptr + 80)
                :print_hexvalue(state + 09, screen_ptr + 83)
                :print_hexvalue(state + 10, screen_ptr + 86)
                :print_hexvalue(state + 11, screen_ptr + 89)

                :print_hexvalue(state + 12, screen_ptr + 120)
                :print_hexvalue(state + 13, screen_ptr + 123)
                :print_hexvalue(state + 14, screen_ptr + 126)
                :print_hexvalue(state + 15, screen_ptr + 129)
}


.macro print_hexvalue(byte, screen_ptr)
{
                lda byte
                lsr
                lsr
                lsr
                lsr
                tax
                lda hexchars, x
                sta screen_ptr

                lda byte
                and #$0f
                tax
                lda hexchars, x
                sta screen_ptr + 1
}

aes_state_str:
.text "AES state:"

subbytes_str:
.text "SubBytes:"

shiftrows_str:
.text "ShiftRows:"

mixcolumns_str:
.text "MixColumns:"

addroundkey_str:
.text "AddRoundKey:"

hexchars:
.text "0123456789abcdef"

//======================================================================
// aes.a65
//======================================================================
