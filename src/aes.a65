//======================================================================
// aes.a65
// -------
// An implementation of the AES-128 block cipher (NIST FIPS-197) for
// the MOS 6502/6510 CPU. The implementation is aimed at low
// cycles/round.
//
// Limitation:
// Currently will only do encipher operation, but one would use
// a cipher mode that provides deciphering outside of the AES itself.
// Key expansion is currently not being implemented.
//
// Implementation note:
// Key and state are stored in zero page using addresses used
// by the BASIC interpreter. Add code to save/restore these values
// before calling the code if BASIC operation is something you
// care about.
//
//
// (c) 2017 Joachim StrÃ¶mbergson
//======================================================================

//------------------------------------------------------------------
// Basic start code.
//------------------------------------------------------------------
.pc = $0801     "Basic uppstart"
	:BasicUpstart(start)


//------------------------------------------------------------------
//------------------------------------------------------------------
// Main program implements a few tests by calling the AES code
.pc = $1000     "Main code"
start:
                lda #$00
                sta $d020
                sta $d021

                jsr subbytes
                rts



//------------------------------------------------------------------
// aes_encipher
// Perform one AES-128 given a block of data written into the
// state and a key written into the key addresses.
//------------------------------------------------------------------

.pc = $2000     "AES Encipher"
aes_encipher:
                sei
                lda #$00
                sta rctr
                sta keyptr

aes1:
                inc rctr
                cmp #$0b
                bne aes1

                cli
                rts


//------------------------------------------------------------------
// SubBytes
// Replace each byte in the state with a byte in the S-box pointed to
// by the state byte value.
//------------------------------------------------------------------
subbytes:
                ldy state + $0
                lda sbox, y
                sta state + $0

                ldy state + $1
                lda sbox, y
                sta state + $1

                ldy state + $2
                lda sbox, y
                sta state + $2

                ldy state + $3
                lda sbox, y
                sta state + $3

                ldy state + $4
                lda sbox, y
                sta state + $4

                ldy state + $5
                lda sbox, y
                sta state + $5

                ldy state + $6
                lda sbox, y
                sta state + $6

                ldy state + $7
                lda sbox, y
                sta state + $7

                ldy state + $8
                lda sbox, y
                sta state + $8

                ldy state + $9
                lda sbox, y
                sta state + $9

                ldy state + $a
                lda sbox, y
                sta state + $a

                ldy state + $b
                lda sbox, y
                sta state + $b

                ldy state + $c
                lda sbox, y
                sta state + $c

                ldy state + $d
                lda sbox, y
                sta state + $d

                ldy state + $e
                lda sbox, y
                sta state + $e

                ldy state + $f
                lda sbox, y
                sta state + $f
                rts


//------------------------------------------------------------------
// ShiftRows
// Rotate the bytes in the rows of the matrix 0..3 steps left.
//------------------------------------------------------------------
shiftrows:
                // Second row one step left.
                lda state + $04
                sta btmp
                lda state + $05
                sta state + $04
                lda state + $06
                sta state + $05
                lda state + $07
                sta state + $06
                lda btmp
                sta state + $07

                // Third row two steps left.
                lda state + $08
                sta btmp
                lda state + $09
                sta btmp + 1
                lda state + $0a
                sta state + $08
                lda state + $0b
                sta state + $09
                lda btmp
                sta state + $0a
                lda btmp + 1
                sta state + $0b

                // Fourth row three steps left.
                lda state + $0c
                sta btmp
                lda state + $0d
                sta btmp + 1
                lda state + $0e
                sta btmp + 2
                lda state + $0f
                sta state + $0c
                lda btmp
                sta state + $0d
                lda btmp + 1
                sta state + $0e
                lda btmp + 2
                sta state + $0f
                rts


//------------------------------------------------------------------
// MixColumns
// GF mult mix columns together.
//------------------------------------------------------------------
mixcolumns:
                rts



//------------------------------------------------------------------
// AddRoundKey
// Xor mix a given round key with the round state.
//------------------------------------------------------------------
addroundkey:
                ldx keyptr
                lda exp_key + $0, x
                eor state + $0
                sta state + $0

                lda exp_key + $1, x
                eor state + $1
                sta state + $1

                lda exp_key + $2, x
                eor state + $2
                sta state + $2

                lda exp_key + $3, x
                eor state + $3
                sta state + $3

                lda exp_key + $4, x
                eor state + $4
                sta state + $4

                lda exp_key + $5, x
                eor state + $5
                sta state + $5

                lda exp_key + $6, x
                eor state + $6
                sta state + $6

                lda exp_key + $7, x
                eor state + $7
                sta state + $7

                lda exp_key + $8, x
                eor state + $8
                sta state + $8

                lda exp_key + $9, x
                eor state + $9
                sta state + $9

                lda exp_key + $a, x
                eor state + $a
                sta state + $a

                lda exp_key + $b, x
                eor state + $b
                sta state + $b

                lda exp_key + $c, x
                eor state + $c
                sta state + $c

                lda exp_key + $d, x
                eor state + $d
                sta state + $d

                lda exp_key + $e, x
                eor state + $e
                sta state + $e

                lda exp_key + $f, x
                eor state + $f
                sta state + $f

                txa
                adc $10
                sta keyptr
                rts



//------------------------------------------------------------------
// AES S-Box.
//------------------------------------------------------------------
.pc = $4000     "Sboxes"
sbox:
.byte $63, $7c, $77, $7b, $f2, $6b, $6f, $c5
.byte $30, $01, $67, $2b, $fe, $d7, $ab, $76
.byte $ca, $82, $c9, $7d, $fa, $59, $47, $f0
.byte $ad, $d4, $a2, $af, $9c, $a4, $72, $c0
.byte $b7, $fd, $93, $26, $36, $3f, $f7, $cc
.byte $34, $a5, $e5, $f1, $71, $d8, $31, $15
.byte $04, $c7, $23, $c3, $18, $96, $05, $9a
.byte $07, $12, $80, $e2, $eb, $27, $b2, $75
.byte $09, $83, $2c, $1a, $1b, $6e, $5a, $a0
.byte $52, $3b, $d6, $b3, $29, $e3, $2f, $84
.byte $53, $d1, $00, $ed, $20, $fc, $b1, $5b
.byte $6a, $cb, $be, $39, $4a, $4c, $58, $cf
.byte $d0, $ef, $aa, $fb, $43, $4d, $33, $85
.byte $45, $f9, $02, $7f, $50, $3c, $9f, $a8
.byte $51, $a3, $40, $8f, $92, $9d, $38, $f5
.byte $bc, $b6, $da, $21, $10, $ff, $f3, $d2
.byte $cd, $0c, $13, $ec, $5f, $97, $44, $17
.byte $c4, $a7, $7e, $3d, $64, $5d, $19, $73
.byte $60, $81, $4f, $dc, $22, $2a, $90, $88
.byte $46, $ee, $b8, $14, $de, $5e, $0b, $db
.byte $e0, $32, $3a, $0a, $49, $06, $24, $5c
.byte $c2, $d3, $ac, $62, $91, $95, $e4, $79
.byte $e7, $c8, $37, $6d, $8d, $d5, $4e, $a9
.byte $6c, $56, $f4, $ea, $65, $7a, $ae, $08
.byte $ba, $78, $25, $2e, $1c, $a6, $b4, $c6
.byte $e8, $dd, $74, $1f, $4b, $bd, $8b, $8a
.byte $70, $3e, $b5, $66, $48, $03, $f6, $0e
.byte $61, $35, $57, $b9, $86, $c1, $1d, $9e
.byte $e1, $f8, $98, $11, $69, $d9, $8e, $94
.byte $9b, $1e, $87, $e9, $ce, $55, $28, $df
.byte $8c, $a1, $89, $0d, $bf, $e6, $42, $68
.byte $41, $99, $2d, $0f, $b0, $54, $bb, $16


//------------------------------------------------------------------
// Zero Page data.
//------------------------------------------------------------------
// 16 bytes AES state
.pc = $30       "State"
state:
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00


// 160 bytes expanded keys
.pc = $40     "Expanded Keys"
exp_key:
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00


// Round counter
.pc = $f8       "Operational variables"
rctr:   .byte $00
keyptr: .byte $00
btmp:   .byte $00, $00, $00, $00


//======================================================================
// aes.a65
//======================================================================
